---
date: 2020-11-07 15:15
description: إزاي تعرف المساحة اللي التايبس بتاعتك بتاخده في الميموري ؟
tags: Computer Science, Arabic, Memory
---
# إزاي تعرف احجام ال Types بتاعتك في سويفت ؟ 

في سويفت، اي اوبجيكت او تايب، ليه ٣ خصائص ممكن يعبرولك عن تعامل الميموري مع الأوبجيكت دا، هنتعرف على خاصيتين من الخصائص دي
في التدوينة دي، و بعضها فيه تدوينات اخرى، 


الخصائص اللي هنتكلم عنها النهاردة هي  Size , alignment 


## الحجم | Size 📦

---


لو عندك اتنين ```struct```  في البرنامج بتاعك زي دول: 

```
struct Student {
    let age: Int
}

struct Professor {
    let age: Int
    let phoneNumber: Int
}

let mostfa = Student(age: 10)
let ahmed = Professor(age: 10, phoneNumber: 010)

```

و سألتك تتوقع الأوبجيكت اللي اسمه مصطفى اكبر ؟ ولا الللي اسمه احمد ؟ بالمنطق، الأوبجيكت اللي اسمه احمد 
اكبر علشان هو مكون من متغيرين، ```age```  و  ```phoneNumber```

بس ازاي نتأكد من انه كلامنا صح ؟ لازم ارقام تثبت صحة كلامنا ؟ علشان نتأكد هنستخدم MemoryLayout 



## 💻 Memory Layout 
---

فيه في سويفت نوع اسمه MemoryLayout النوع دا بيخلينا نقدر نتأكد من احجام الأنواع اللي عندنا زي Student و Professor و اي نوع في سويفت زي String و Bool
علشان نعرف الSize اللي اي اوبجيكت من نوع Student او من نوع Professor هياخده من الميموري: 

```
let studentSize = MemoryLayout<Student>.size
let professorSize = MemoryLayout<Professor>.size


print(studentSize) // prints 8
print(professorSize) //prints 16 😉
```

هنا استخدمنا MemoryLayout و طلبنا منها تجيب حجم/size اي اوبجيكت هيتعمل من الtypes هيبقى حجمه كام
زي ما توقعنا، professor هتاخد مساحة اكبر من الميموري

ولو عاوزين نتأكد من الكلام على الأوبجيكتس، زي اوبجيكت آحمد و مصطفى اللي فوق


```
let /§mostfaSize§/ = MemoryLayout.size(ofValue: mostfa)
let ahmedSize = MemoryLayout.size(ofValue: ahmed)

print(/§mostfaSize§/) //prints 8 
print(ahmedSize) //also prints 16 
```

لكن ليه ؟ ليه ٨ ؟ و ليه ١٦ ؟ نرجع تاني للحجم  


##  للحجم | Size 
##  نرجع للحجم | Size 📦

---


في سويفت سهل انك تحسب حجم اي ستراكت في البرنامج، لأنه حجم الستراكت = حجم المتغيرات اللي جواه  بمعنى إيه ؟
بمعنى انه 

```
struct Student {
    /§ let age: Int §/
   /~ let inSchool: Bool ~/
}

/§ let intSize = MemoryLayout<Int>.size §/ //prints out 8
/~ let boolSize = MemoryLayout<Bool>.size ~/ //prints out 1

let studentSize = MemoryLayout<Student>.size //prints out 9 ( 1+ 8 )

```
علشان الستراكت دا متكون من متغير من نوع Int و متغير من نوع Bool , حجمه هيساوي مجموع حجم الBool و حجم الInt ، سهلة خالص، صح ؟🦹🏻‍♂️

طيب خلينا نتأكد بمثال تاني 

```
struct OtherStudent {
    let inSchool: Bool
    let age: Int
}
```
هنا دا OtherStudent نفس الStudent اللي فوق بالظبط، لكن الفرق اننا غيرنا ترتيب الproperties
بتاعتنا، المفروض يكون نفس الSize  ؟!!!

```
let OtherStudentSize = MemoryLayout<OtherStudent>.size // 16 <- but why ? 😲
```

في الحقيقة، انه تغير ترتيب الproperties بتاعتنا، بس، ادى انه الsize يتغير ⚠️
ليه ؟ دا هيودينا لمفهوم   جديد وهو Memory Alignment, هنتكلم عنه بعدين نفهم ازاي سبب اثر على ال Size


## 💻 Memory Alignment 
---
علشان نتكلم عن ال Memory alignment محتاجين نرجع لأساس البروسيسور بيشتغل ازاي، و ازاي بيجيب البيانات من الميموري 

بشكل عام في الكمبيوتر البروسيسور او المعالج، هو اللي بيروح يطلب البيانات بتاعتنا في الميموري،

![image info](https://i.ibb.co/rwT8TGK/Screen-Shot-2020-11-07-at-7-34-38-PM.png)
لو افترضنا انه عندنا بروسيسور بيقدر يجيب بايت واحدة بس في الطلب الواحد من الميموري
اللي هيحصل انه البروسيسور علشان يجيب بيانات اللي بالبرتقالي دي 
هيحتاج يعمل طلبين 
طلب يطلب فيه البيانات اللي في الصف 0 و طلب للبيانات اللي في صف ١
طلب لقراءة البايت الاولى، و طلب لقراءة البايت التانية، زي ما باين في الصورة

لو كل طلب بياخد ١ ملي ثانية، الطلبين علشان يتنفذو هياخدوا ٢ ملي ثانية


جميل، لو جبنا معالج جديد، والمعالج دا يقدر يجيب صفين  في الطلب الواحد من الميموري 
دا معناه انه المعالج بينظر للميموري على هيأة ٢ ، و بيقسمها اتنين-ات
![image info](https://i.ibb.co/gVGDd3f/Screen-Shot-2020-11-07-at-7-38-25-PM.png)

لو افترضنا انه البيانات بتاعتك كلها، موجودة في اول صفين، بالنسبة للمعالج لما يجي يطلب من الميموري 
هيقولها هاتيلي الحاجة اللي في الصف رقم 0

كدا قدرت تحصل على بياناتك كلها، في طلب واحد بس، و كدا اسرع !
دا معناه انه علشان احصل على بياناتي حصلت عليها في طلب واحد بس، يعني 50% اسرع


المشكلة بتحصل لو البيانات بتاعتك محطوطة بطريقة زي دي:
![image info](https://i.ibb.co/W2CxZNg/Screen-Shot-2020-11-07-at-7-39-59-PM.png)

هنا علشان تحصل على معلوماتك، لازم البروسيسور يعمل طلب لقراءة  الصف رقم ١، و بكدا يكون حصل على نص واحد بس من البيانات
علشان يوصل للنصف التاني، محتاج يعمل طلب تاني، عند الصف رقم ٢

وبعدين يشيل النص الاولاني الفاضي من الصف ١، وبعدين يشيل النص التاني الفاضي من الصف ٢، و يديلك المعلومة  بتاعتك
كدا النتيجة بطيئة، علشان البيانات بتاعتك، اتحطت في مكان،
 الماكن دا ادى انه البروسيسور محتاج يبذل عمليات اكتر علشان يحصل عليها
 
 المشكلة دي بتسمى misaligned data  misalignment 

الحل ليها انه احنا نعمل شيفت للداتا بتاعتنا، بحيث يقدر المعالج، يجيبها، في طلب واحد فقط بس من الميموري، او اقل عدد طلبات ممكن 

![image info](https://i.ibb.co/ZSHmJwK/Screen-Shot-2020-11-07-at-7-28-58-PM.png)

الكلام دا معناه انه احيانًا بضطر اسيب اماكن فاضية في الميموري، علشان بعمل شيفت للبيانات بتاعتي، و بيبقى مكان الشيفت دا، اماكن غير مستخدمة

ازاي دا بيفرق معانا في سويفت ؟ 

##  Alignment for basic types 🎲
---

لكل Type في  سويفت يوجد قيمة اسمها Alignment

```
let IntegerAlignment = MemoryLayout<Int>.alignment //prints out 8 
```
ال Alignment لأي Integer في سويفت عبارة عن ٨، الرقم دا معناه إيه ؟ 
معناه انه عنوان الMemory  اللي هيتم وضع فيه الInteger لازم يكون من مضاعفات ال٨

لو عندي الكود الآتي
```
let A = 88
let b = 17
```
![image info](https://i.ibb.co/P5JYfLY/image.png)
دا معناه انه المتغير A و b لازم يتحطوا في عنوان ميموري من مضاعفات ال٨، 
نلاحظ عنوان الميموري للمتغير A في الصورة = صفر، و بما انه الصفر من مضاعفات ال٨، يبقى معندناش مشكلة 
ايضًا، المتغير b موجود في العنوان ٨ وبما انه ال٨ من مضاعفات ال ٨ ايضًا معندناش مشاكل 

---

امتى يكون عندنا مشكلة ؟ يكون عندنا مشكلة في الموقف الآتي 

![image info](https://i.ibb.co/T1nfzQs/image.png)

```
/*
A lot of other code in the app which will be saved in memory 
.
.
.
.
.
.
*/

let A = 88
```

لو فيه بيانات اخرى Other موجودة في الميموري من العنوان صفر الى العنوان ٤ ، و جينا نحط المتغير a في العنوان رقم ٥، مش هنقدر !
ليه ؟ لأنه طبقًا ل Alignment الخاص ب Integer لازم يتم وضعه في عنوان من مضاعفات ال ٨ وبناء عليه هيتم وضع المتغير A
في العنوان رقم ٨، و هيكون العناوين ٥،٦،٧ فاضيين

ومن هنا نقدر نرجع للسؤال الأساسي، ليه OtherStudent حجمه اختلف عن Student 

## Alignment and size 🎳
---


```
let boolAlignment = MemoryLayout<Bool>.alignment //prints out 1
let IntegerAlignment = MemoryLayout<Int>.alignment //prints out 8 

```

```
struct Student {
    /§ let age: Int §/
   /~ let inSchool: Bool ~/
}

```
بمعرفة انه ال Alignment للBool يساوي ١، دا يعني انه ممكن احط الBoolean values
في اي عنوان في الميموري، لأنه كل الارقام تعتبر من مضاعفات الواحد، 
وايضا بمعرفة انه الAlignment للIntegers يساوي ٨ دا معناه انه 
ممكن نحط الIntegers في العنواين اللي من مضاعفات ٨

![image info](https://i.ibb.co/1rds68Y/image.png)

هنا، الInteger عنوان صفر، و الصفر من مضاعفات ال ٨

و الBoolean عنوان٨، و ال٨ من مضاعفات ال
١
ودا معناه انه ال Alignment تحقق و شغال و زي الفل
و بناء عليه حجم الStudent يساوي ٩

---


```
struct OtherStudent {
    let inSchool: Bool
    let age: Int
}
```
لو جينا نطبق قواعد الAlignment هنا هنلاقي الآتي 

![image info](https://i.ibb.co/hWPkxNH/image.png)
اول حاجة هيتم وضع الBoolean value في العنوان صفر، و لأنه الصفر من مضاعفات ال١، الAlignment تصبح مظبوطة ✅

لكن الInteger مينفعش يتحط في العنوان رقم ١ ❌ لأن العنوان رقم ١ مش من مضاعفات ال ٨
وبناء عليه هيتم تركه فاضي، وترك جميع العناوين
اللي مش من مضاعفات ٨ فاضية، حتى نصل الى اول رقم من مضاعفات ٨، وهو ال ٨، ونحط فيه الInteger

النتيجة هنا، انه بسبب ال Alignment اصبح الstruct حجمه  ١٦ 🤯


To be continued ...
